diff --git a/README.md b/README.md
index f35defc..7a19ab1 100644
--- a/README.md
+++ b/README.md
@@ -1,2 +1,7 @@
 # Pyadb-ftracer
 Wrapper around pyadb to perform easy ftrace scripting. Something I will probably develop slowly over the years as I need it.
+
+
+## TODO
+
+ - CPU weightings for work calculations
diff --git a/adbinterface.py b/adbinterface.py
index a31cef7..bd1493a 100644
--- a/adbinterface.py
+++ b/adbinterface.py
@@ -6,6 +6,8 @@ from adb import sign_m2crypto
 
 class adbInterface:
 
+    current_interface = None
+
     def __init__(self):
         #logger
         logging.basicConfig(filename="pytracer.log",
@@ -17,6 +19,7 @@ class adbInterface:
         self.device = adb_commands.AdbCommands()
         self.device.ConnectDevice(rsa_keys=[signer])
         self.logger.debug("ADB interface created")
+        adbInterface.current_interface = self
 
         #traces
         self.tracers = []
diff --git a/event.py b/event.py
index 312a9bf..7935556 100644
--- a/event.py
+++ b/event.py
@@ -52,10 +52,11 @@ class EventSchedSwitch(Event):
 
 class EventFreqChange(Event):
 
-    def __init__(self, PID, time, cpu, freq, load):
+    def __init__(self, PID, time, cpu, freq, load, target_cpu):
         Event.__init__(self, PID, time, cpu, "freq change")
         self.freq = freq
         self.load = load
+        self.target_cpu = target_cpu
 
 
 class EventWakeup(Event):
@@ -73,7 +74,7 @@ class EventIdle(Event):
 
 class EventBinderCall(Event):
 
-    def __init__(self, PID, time, cpu, name, trans_type, dest_proc, trans_ID, flags, code):
+    def __init__(self, PID, time, cpu, name, trans_type, dest_proc, flags, code):
         Event.__init__(self, PID, time, cpu, name)
         if trans_type == 0:
             if flags & 0b1:
@@ -85,7 +86,6 @@ class EventBinderCall(Event):
         else:
             self.trans_type = BinderType.UNKNOWN
         self.dest_proc = dest_proc
-        self.trans_ID = trans_ID
         self.flags = flags
         self.code = code
         self.recv_time = 0
@@ -129,12 +129,13 @@ class TaskNode:
         if isinstance(event, EventSchedSwitch):
             self.graph.add_node(event, label= str(event.time)[:-6] + "." + str(event.time)[-6:] +
                 " CPU: " + str(event.cpu) + "\n" + str(event.PID) + " ==> " + str(event.next_pid) +
-                "\nPrev state: " + str(event.prev_state) + "\n" + str(event.name) + "\n" + str(event)
+                "\nPrev state: " + str(event.prev_state) + "\n" + str(event.name) +
+                "\n" + str(event.__class__.__name__)
                 , fillcolor='bisque1', style='filled')
         elif isinstance(event, EventBinderCall):
             self.graph.add_node(event, label= str(event.time)[:-6] + "." + str(event.time)[-6:] +
                 " CPU: " + str(event.cpu) + "\n" + str(event.PID) + " ==> " + str(event.dest_proc) +
-                "\n" + str(event.name) + "\n" + str(event), fillcolor='aquamarine1',
+                "\n" + str(event.name) + "\n" + str(event.__class__.__name__), fillcolor='aquamarine1',
                 style='filled')
 
         # create graph edge if not the first job
@@ -174,9 +175,16 @@ class CPUBranch:
         # create new event
         self.events.append(event)
 
-        # These edges simply follow a PID, do not show any IPCs or IPDs
-        if len(self.events) >= 2:
-            self.graph.add_edge(self.events[-2], self.events[-1], style='bold')
+        self.graph.add_node(self.events[-1],
+                label = str(self.events[-1].time)[:-6] + "." + str(self.events[-1].time)[-6:]
+                    + "\n CPU: " + str(event.cpu) + " Load: " + str(event.load)
+                    + "\n Freq: " + str(event.freq)
+                    + "\n" + str(event.__class__.__name__), style='filled')
+
+        # # These edges simply follow a PID, do not show any IPCs or IPDs
+        # if len(self.events) >= 2:
+        #     self.graph.add_edge(self.events[-2], self.events[-1], style='bold')
+
 
 class ProcessBranch:
 
@@ -253,7 +261,7 @@ class ProcessBranch:
                     + str(self.tasks[-1].finish_time)[-6:]
                     + " CPU: " + str(event.cpu) + "\npid: " + str(event.PID) + "\n" + str(event.name)
                     + "\nDuration: " + str(self.tasks[-1].exec_time)
-                    + "\n" + str(self.tasks[-1]), fillcolor='darkolivegreen3', style='filled,bold,rounded')
+                    + "\n" + str(self.tasks[-1].__class__.__name__), fillcolor='darkolivegreen3', style='filled,bold,rounded')
 
             # link task node to beginning of sub-graph
             self.graph.add_edge(self.tasks[-1], self.tasks[-1].events[0], color='blue',
@@ -274,7 +282,7 @@ class ProcessBranch:
                 label=str(self.tasks[-1].start_time)[:-6]
                     + "." + str(self.tasks[-1].start_time)[-6:] + "\npid: " + str(event.PID)
                     + "  dest PID: " + str(event.dest_proc)
-                    + "\n" + str(event.name) + "\n" + str(self.tasks[-1]),
+                    + "\n" + str(event.name) + "\n" + str(self.tasks[-1].__class__.__name__),
                     fillcolor='coral', style='filled,bold')
             return
 
@@ -394,7 +402,6 @@ class ProcessTree:
                         del self.pending_binder_tasks[x]
                         return
 
-                #TODO check this
                 process_branch.add_job(event, event_type=JobType.SCHED_SWITCH_IN)
 
             return
@@ -404,10 +411,9 @@ class ProcessTree:
         # in relation to the system configuration as they were executed.
         elif isinstance(event, EventFreqChange):
             # update cpu freq
-            print event.cpu
-            self.metrics.core_freqs[event.cpu] = event.freq
-            # add event to cpu branch
-            self.cpus[event.cpu].add_job(event)
+            # self.metrics.core_freqs[event.cpu] = event.freq
+            # # add event to cpu branch
+            # self.cpus[event.cpu].add_job(event)
 
             return
 
@@ -469,6 +475,7 @@ class ProcessTree:
                             del self.pending_binder_transactions[x]
                             return
             else:
+                #TODO
                 print "Unhandled binder"
 
             return
diff --git a/pidtrace.py b/pidtrace.py
index e54c5e7..8158bb3 100644
--- a/pidtrace.py
+++ b/pidtrace.py
@@ -113,6 +113,7 @@ class PIDtracer:
             # Check that parent threads are in system server threads. This catches threads
             # such as the media codec which is commonly used but is not a system service
             parent_pid = int(re.findall("{Binder:(\d+)_.+}", line)[0])
+
             # process will be first line as it's PID will be lower than child threads and as
             # such will be higher is list
             if not any(proc.pid == parent_pid for proc in self.allSystemPID):
@@ -121,7 +122,7 @@ class PIDtracer:
                 for line in parent_thread:
                     if "grep" not in line:
                         pname = re.findall(".* +(.*)$", line)[0]
-                        tname = tname = re.findall("\{(.*)\}", line)
+                        tname = re.findall("\{(.*)\}", line)
                         if not tname:
                             tname = pname
                         self.allSystemPID.append(PID(pid, pname, tname))
diff --git a/traceprocessor.py b/traceprocessor.py
index 5f7faa2..5215ece 100644
--- a/traceprocessor.py
+++ b/traceprocessor.py
@@ -1,5 +1,7 @@
 import logging
 from aenum import Enum
+from numpy.f2py.auxfuncs import throw_error
+
 from event import *
 import re
 import sys
@@ -49,12 +51,22 @@ class traceProcessor:
         return EventWakeup(pid, time, cpu, name)
 
     def _processSchedSwitch(self, line):
-        pid =  int(re.findall("-(\d+) *\[", line)[0])
-        time = int(round(float(re.findall(" (\d+\.\d+):", line)[0]) * 1000000))
-        cpu = int(re.findall(" +\[(\d+)\] +", line)[0])
-        name = re.findall("^ *(.+)-\d+ +", line)[0]
-        prev_state = re.findall("prev_state=([RSDx]{1})", line)[0]
-        next_pid = int(re.findall("next_pid=(\d+)", line)[0])
+        # pid =  int(re.findall("-(\d+) *\[", line)[0])
+        # time = int(round(float(re.findall(" (\d+\.\d+):", line)[0]) * 1000000))
+        # cpu = int(re.findall(" +\[(\d+)\] +", line)[0])
+        # name = re.findall("^ *(.+)-\d+ +", line)[0]
+        # prev_state = re.findall("prev_state=([RSDx]{1})", line)[0]
+        # next_pid = int(re.findall("next_pid=(\d+)", line)[0])
+
+        pid_cpu_time = re.findall("-(\d+) +\[(\d{3})\] .{4} (\d+.\d+)", line)
+        pid = int(pid_cpu_time[0][0])
+        cpu = int(pid_cpu_time[0][1])
+        time = int(round(float(pid_cpu_time[0][2]) * 1000000))
+
+        name_state_next = re.findall("prev_comm=(.+) prev_pid=(\d+) .* prev_state=([RSDx])", line)
+        name = name_state_next[0][0]
+        next_pid = name_state_next[0][1]
+        prev_state = name_state_next[0][2]
 
         return EventSchedSwitch(pid, time, cpu, name, prev_state, next_pid)
 
@@ -67,28 +79,50 @@ class traceProcessor:
         return EventIdle(time, cpu, state, name)
 
     def _processSchedFreq(self, line):
-        pid =  int(re.findall("-(\d+) *\[", line)[0])
-        time = int(round(float(re.findall(" (\d+\.\d+):", line)[0]) * 1000000))
-        cpu = int(re.findall("cpu: (\d+)", line)[0])
-        freq = int(re.findall("freq: (\d+) ", line)[0])
-        load = int(re.findall("load: (\d+)", line)[0])
+        pid_cpu_time = re.findall("-(\d+) +\[(\d{3})\] .{4} (\d+.\d+)", line)
+        pid =  int(pid_cpu_time[0][0])
+        cpu = int(pid_cpu_time[0][1])
+        time = int(round(float(pid_cpu_time[0][2]) * 1000000))
+
+        cpu_freq_load = re.findall("cpu: (\d+) freq: (\d+) load: (\d+)", line)
 
-        return EventFreqChange(pid, time, cpu, freq, load)
+        target_cpu = int(cpu_freq_load[0][0])
+        freq = int(cpu_freq_load[0][1])
+        load = int(cpu_freq_load[0][2])
+
+        return EventFreqChange(pid, time, cpu, freq, load, target_cpu)
 
     def _processBinderTransaction(self, line):
-        pid =  int(re.findall("-(\d+) *\[", line)[0])
-        time = int(round(float(re.findall(" (\d+\.\d+):", line)[0]) * 1000000))
-        cpu = int(re.findall(" +\[(\d+)\] +", line)[0])
-        name = re.findall("^ *(.+)-\d+ +", line)[0]
-        trans_type = int(re.findall(" +reply=(\d) +", line)[0])
-        to_proc = int(re.findall(" +dest_thread=(\d+) +", line)[0])
+        # pid =  int(re.findall("-(\d+) *\[", line)[0])
+        # time = int(round(float(re.findall(" (\d+\.\d+):", line)[0]) * 1000000))
+        # cpu = int(re.findall(" +\[(\d+)\] +", line)[0])
+        # name = re.findall("^ *(.+)-\d+ +", line)[0]
+
+        # trans_type = int(re.findall(" +reply=(\d) +", line)[0])
+        # to_proc = int(re.findall(" +dest_thread=(\d+) +", line)[0])
+        # if to_proc == 0:
+        #     to_proc = int(re.findall(" +dest_proc=(\d+) +", line)[0])
+        # trans_ID = int(re.findall(" +transaction=(\d+) +", line)[0])
+        # flags = int(re.findall(" +flags=(0x[0-9a-f]+) +", line)[0], 16)
+        # code = int(re.findall(" +code=(0x[0-9a-f]+)", line)[0], 16)
+
+        pid_cpu_time = re.findall("^ *(.*)-(\d+) +\[(\d{3})\] .{4} (\d+.\d+)", line)
+
+        name = pid_cpu_time[0][0]
+        pid = int(pid_cpu_time[0][1])
+        cpu = int(pid_cpu_time[0][2])
+        time = int(round(float(pid_cpu_time[0][3]) * 1000000))
+
+        the_rest = re.findall("dest_proc=(\d+) dest_thread=(\d+) reply=(\d) flags=(0x[0-9a-f]+) code=(0x[0-9a-f]+)", line)
+
+        to_proc = int(the_rest[0][1])
         if to_proc == 0:
-            to_proc = int(re.findall(" +dest_proc=(\d+) +", line)[0])
-        trans_ID = int(re.findall(" +transaction=(\d+) +", line)[0])
-        flags = int(re.findall(" +flags=(0x[0-9a-f]+) +", line)[0], 16)
-        code = int(re.findall(" +code=(0x[0-9a-f]+)", line)[0], 16)
+            to_proc = int(the_rest[0][0])
+        trans_type = the_rest[0][2]
+        flags = the_rest[0][3]
+        code = the_rest[0][4]
 
-        return EventBinderCall(pid, time, cpu, name, trans_type, to_proc, trans_ID, flags, code)
+        return EventBinderCall(pid, time, cpu, name, trans_type, to_proc, flags, code)
 
     def writeToXlsx(self, processed_events, filename):
         #write events into excel file
@@ -247,7 +281,10 @@ class traceProcessor:
         processed_events = []
 
         if metrics is None:
-            metrics = SystemMetrics(adbInterface())
+            if adbInterface.current_interface is not None:
+                metrics = SystemMetrics(adbInterface.current_interface)
+            else:
+                sys.exit("Need adb insterface to process trace file")
 
         #Filter and sort events
         self.logger.debug("Trace contains " + str(len(raw_lines)) + " lines")
